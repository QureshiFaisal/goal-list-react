function cssBlankPseudo(document, opts) {
  // configuration
  const className = Object(opts).className;
  const attr = Object(opts).attr || 'blank';
  const force = Object(opts).force;

  try {
    document.querySelector(':blank');

    if (!force) {
      return;
    }
  } catch (ignoredError) {}
  /* do nothing and continue */
  // observe value changes on <input>, <select>, and <textarea>


  const window = (document.ownerDocument || document).defaultView;
  observeValueOfHTMLElement(window.HTMLInputElement);
  observeValueOfHTMLElement(window.HTMLSelectElement);
  observeValueOfHTMLElement(window.HTMLTextAreaElement);
  observeSelectedOfHTMLElement(window.HTMLOptionElement); // form control elements selector

  const selector = 'INPUT,SELECT,TEXTAREA';
  const selectorRegExp = /^(INPUT|SELECT|TEXTAREA)$/; // conditionally update all form control elements

  Array.prototype.forEach.call(document.querySelectorAll(selector), node => {
    if (node.nodeName === 'SELECT') {
      node.addEventListener('change', configureCssBlankAttribute);
    } else {
      node.addEventListener('input', configureCssBlankAttribute);
    }

    configureCssBlankAttribute.call(node);
  }); // conditionally observe added or unobserve removed form control elements

  new MutationObserver(mutationsList => {
    mutationsList.forEach(mutation => {
      Array.prototype.forEach.call(mutation.addedNodes || [], node => {
        if (node.nodeType === 1 && selectorRegExp.test(node.nodeName)) {
          if (node.nodeName === 'SELECT') {
            node.addEventListener('change', configureCssBlankAttribute);
          } else {
            node.addEventListener('input', configureCssBlankAttribute);
          }

          configureCssBlankAttribute.call(node);
        }
      });
      Array.prototype.forEach.call(mutation.removedNodes || [], node => {
        if (node.nodeType === 1 && selectorRegExp.test(node.nodeName)) {
          if (node.nodeName === 'SELECT') {
            node.removeEventListener('change', configureCssBlankAttribute)